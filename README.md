# Azure Graph Automation Infrastructure

This is the infrastructure I use to support my Graph User Photo Sync automation. I provision it all using [Terraform](https://www.terraform.io/) and deploy it using [GitHub Actions](https://docs.github.com/en/actions).

Here's what I’m setting up:

- A Resource Group
- An Azure Automation Account
- A Managed Identity
- My PowerShell Runbook
- A GitHub Actions CI/CD workflow

If you're looking for the actual PowerShell automation logic that syncs user photos to Microsoft Graph, that's in my [graph-automation](https://github.com/AllwaysHyPe/graph-automation) repo.

## Repo Structure

```
graph-automation-infra/
├── .github/workflows/        # GitHub Actions for CI/CD
├── modules/graph-photo-sync/ # Terraform module
├── Scripts/                  # PowerShell automation scripts
│   ├── GraphUserPhotoSync-Automation.ps1
│   └── New-AzGraphAutomationServicePrincipal.ps1
├── main.tf                   # Root Terraform configuration
├── variables.tf              # Input variables
└── README.md
```

## Getting Started

### 1. Clone this repository

```powershell
git clone https://github.com/AllwaysHyPe/graph-automation-infra.git
Set-Location graph-automation-infra
```

### 2. Configure Azure authentication

I’ve included a script that creates a scoped service principal specifically for this Terraform deployment:

```powershell
.\Scripts\New-AzGraphAutomationServicePrincipal.ps1 `
    -ResourceGroupName "my-resource-group" `
    -SubscriptionId "00000000-0000-0000-0000-000000000000"
```

That script will output everything you need to create the GitHub repository secrets:

- AZURE_CLIENT_ID
- AZURE_CLIENT_SECRET
- AZURE_SUBSCRIPTION_ID
- AZURE_TENANT_ID

### 3. Initialize Terraform locally

If you want to test everything from your terminal:

```powershell
terraform init
terraform plan -out=tfplan
terraform apply tfplan
```

You can also trigger the GitHub Actions workflow manually from the Actions tab.

## Security Note

For GitHub Actions, I use a dedicated service principal with **Contributor** permissions scoped only to the resource group. I intentionally avoid granting `Owner` permissions.

If you're building on top of this, here’s how to harden it further:
- Use GitHub's OpenID Connect (OIDC) to eliminate secrets entirely
- Assign custom roles if you don’t need full Contributor access
- Rotate client secrets regularly or use certificates instead

## Inputs

These are the Terraform variables I use. You can customize them using `terraform.tfvars` or pass them via CLI:

| Variable                  | Description                          | Default                             |
|---------------------------|--------------------------------------|-------------------------------------|
| `resource_group_name`     | Azure resource group name            | —                                   |
| `location`                | Azure region                         | `westus`                            |
| `automation_account_name` | Name of the automation account       | —                                   |
| `runbook_name`            | Name of the runbook                  | `GraphUserPhotoSync`               |
| `script_path`             | Path to the automation script        | `./Scripts/GraphUserPhotoSync-Automation.ps1` |

## GitHub Actions Workflow

My pipeline includes:

- Azure login using the service principal
- Terraform init, plan, and apply steps
- Runbook upload and publish

I’ve set it up with a `workflow_dispatch` trigger so you can run it manually.

## .gitignore

I’ve added a `.gitignore` that excludes Terraform state files, secrets, and anything generated by local editors or terminals.

## Future Improvements

Here are a few things I may add later:

- Hybrid Worker group provisioning
- Arc-enabled server registration
- Log Analytics integration
- Role assignment for Microsoft Graph API scopes
- A cleanup script to remove the service principal when it's no longer needed

